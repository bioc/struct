---
title: STRUCT Model Template
author: 
  name: Dr Gavin Rhys Lloyd
  affiliation: Phenome Centre Birmingham, University of Birmingham, UK
output:
  BiocStyle::html_document:
    toc_float: true
  BiocStyle::pdf_document: default
vignette: >
    %\VignetteIndexEntry{STRUCT Model Template}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---
    
```{r,include=FALSE,purl=FALSE}
library("struct")
```
    
Please note: the **Using the template** section of this vignette describes the contents of a 
class object broken down into sections. As such, some of the lines cannot be run 
on their own. Please skip to the **Complete object**
section for a working example. 

Alternatively, you may find the the functions described in the **Using helper functions** sections 
an easier approach (recommended).

# Using helper functions

STRUCT provides a number of helper functions that can be used to create a new struct object from the command line, or in a script:

- `set_struct_obj()`: used to create a new struct object
- `set_obj_method()`: used to modify a method for a struct object
- `set_obj_show()`: used to modify the displayed output for a struct object

## Creating a new struct object

To create a new struct object use the `set_struct_obj()` function. There are several inputs which are described below.

- `class_name`    The name of the new struct object (character).
- `struct_obj`    The type of struct object to create e.g. model, iterator, metric, etc.
- `stato`         TRUE (default) or FALSE to add stato functionality to the object
- `params`        A named vector of types for input slots. The names will become slotnames and the types will be used to determine                     what type of assignments are allowed to the named slot (e.g. integer, character etc).
- `outputs`       As `params`, but for output slots.
- `private`       As `params` and `outputs` but for slots that are used internally by the object and not intended for use by the                      user. These slots are only accessible using \@.
- `prototype`      A named list of default values for each input/output/private slot.
- `where`         Specifies the environment in which the class definition is created. Default is `.GlobalEnv`

To demonstrate, a new model object that simply adds two inputs together will be defined.

```{r}
set_struct_obj(
  class_name = 'add_two_inputs',
  struct_obj = 'model',
  stato = FALSE,
  params=c(input_1 = 'numeric', input_2 = 'numeric'),
  outputs=c(result = 'numeric'),
  prototype=list(
    input_1 = 0, 
    input_2 = 0,
    name='Add two inputs',
    description='example class that adds two values together')
  )
```

The class definition will by default be created with the name `class_name` in the `.GlobalEnv`, unless you specify otherwise using the `where` parameter. We can check that creation of the class defintion by calling `show` on the definition:

```{r}
# show the class definition
show(add_two_inputs)
```

The definition has been created but the object only has the default STRUCT methods (such as `model.apply`) assigned and so doesnt do anything yet. The default methods can be updated using other helper funtions which are described in the following sections.

## Changing the default methods

All struct objects have some default methods that are intended to be "overloaded" i.e. replaced to provide functionality specific to the new object being implemented. The helper function `set_obj_method()` provides this functionality with the following inputs:


For the example object that adds two values together, we will overload the `model.apply` method.

```{r}
set_obj_method(
  class_name = 'add_two_inputs',
  method_name = 'model.apply',
  definition = function(M,D) { # you need to supply D here even if you dont use it
    M$result = M$input_1 + M$input_2
    return(M)                  # remember to always return the input object after modifying it
  }
)
```

The default `method.apply` method for the `add_two_inputs` model has now been updatded. We can check this by creating an instance of our model, setting the two input values and then calling `method.apply` on our model object.

```{r}
# create an instance of the model
M = add_two_inputs(input_1 = 3, input_2 = 5)
# use the model
M = model.apply(M,dataset())
# check the result = 8
M$result
```

We can see that the result is 8, so the new definition for `model.apply` was used successfully.

As well as overloading default STRUCT methods (such as `model.apply`, `model.train`, `model.precict` etc) it is also helpful to overload the extend the default `show` method to make the displayed output more informative for the new object. This is described in the following sections.

## Changing the default `show` output

All STRUCT objects have a default show output, which prints the name and description for an object.

```{r}
show(add_two_inputs())
```

If you want to provide additional information when printing the new object then you can overload the show method using the `set_obj_show()` function, which has the following inputs:

- `class_name`        the name of the class to update the show method for
- `extra_string`:     a function that takes the `class_name` object as input and outputs a string

The string output from the `extra_string` function will be appended to the default `show` output. For the example object we will print the inputs in addition to the standard output.

```{r}
# update the show method
set_obj_show(
  class_name = 'add_two_inputs',
  extra_string = function(x) {
    str= paste('\nThis model is currently set to calculate: ',x$input_1,' + ', x$input_2,sep='')
    return(str)
  }
)

```

We can check the new show method by calling `show` on the object:

```{r}
# call the show method
show(M)
```

The additonal text `This model is currently set to calculate: 3 + 5` is included, so extending the default show method was successful.

# Using the templates

If you want to output the full model template to an editable R script you can 
use the `struct_template` function. The `type` parameter specifies the template 
to access (in this case "model") and the file to save the template to. If no 
path is specified the file will be created in your working directory.
    
```r
struct_template(template='model',output='example.R',overwrite=TRUE, in_editor=FALSE)`
```
    
You can browse all the templates, available as vignettes in the STRUCT package
using the `browseVignettes` function. Viewing the HTML will show this page, and 
viewing the R code will display a working template.
    
```r
browseVignettes('struct')
```
    
***After editing the template*** you can source the script to use your new 
model. You can add the script to your own package, or potentially even submit 
it to us for inclusion in the `structToolbox` package.
    
```{r}
## example use
# create an instance of your object
M = example_model()
# get/set parameters
M$value_1 = 5
M$value_1 # 5
# train your model with some data
M = model.train(M,iris_dataset())
# apply your model to some test data
M = model.predict(M,iris_dataset())
```
    
You might find it useful to create some chart objects for your new model object. 
See the `chart` template for help to do this.
    
***
    
# Template walkthrough
    
## Class definition
The model templates are based on inheriting the `model` or `model.stato` classes 
from the StRUCT package. This means all the functionality already created as 
part of struct will be available to the new class.

First, a new class object is set up using the `setClass` function. The 
`setClass` function contains a number of inputs, which will be illustrated in 
the following steps.

```r
model_template=setClass('model_template', # replace model_template (both places) 
# with your new model name
contains = c('model','stato'),        # 'stato' is optional
```

The `contains` option  tells R which aspects of STRUCT to include in the new
model.
    
***
    
### Slots for parameters and outputs
    
After defining the name of your new class and specifying that it contains the 
`model` and (optionally) the `stato` class, the *slots* are defined. Slots are 
variables that are associated with the object that are intended to be accessable
by the user. It is here that you specify the input parameters and outputs for 
your class. Input parameters should have `params.` appended and outputs should 
have `outputs.` appended. 
    
Default slots like `name`, `description` and `type` are inherited (i.e. provided 
by STRUCT) and do not need to be specified. 
    
A type should be indicated for each slot e.g. `numeric`. Some special types
are available in STRUCT, namely `entity` and `enum`, and we recommend you use
these where possible because they allow you to provide additonal information
(`name`, `description` etc) about the parameters/outputs.
    
To use `entity` objects for parameters and/or outputs, specify `entity` 
as the type. If you want to enable STATO functionality for your parameters then 
you can specify `entity.stato` as the type.

```r
slots=c(
'params.value_0'='entity',
'params.value_1'='entity.stato',
'params.value_2'='numeric',
'outputs.result_1'='entity',
'outputs.result_2'='numeric'
),
```
    
***
    
### Prototypes
    
#### Model protoype
You can also optionally include a list of prototypes. Protoypes are used to 
define default values for parameters. It is recommended that the `name`, 
`description` and `type` are defined here for your model.

```r
prototype = list(
## These are the default slots available for every struct object
name='A test model',
description='An example model object. Training adds value_1 counts to
a dataset, while prediction adds value_2 counts.',
type='test',

## This is slot is only required for stato objects
stato.id='OBI:0000011',
```


STATO objects can also have a `stato.id` assigned in the protoype list. It 
must be assigned when the class is defined, as no mechanism is provided for 
changing it by the user (other than using @ which is discouraged). 

STATO names and definitions can then be extracted from the STATO database based 
on the supplied id. To search for a relevant ID see http://stato-ontology.org/

***

#### Parameter and Output protoypes

Setting an input parameter to an `entity` object allows default slots for this 
parameter so that you can be more descriptive about what it does without using 
lengthy slot names. The `type` slot allows you to specify that the entity should
be of a specific type e.g. 'numeric'. Note that any slot without a prototype
will be initialised as NULL or a vector or zero length of the appropriate class
e.g `numeric(0)`.

```r
## parameters all start with params.
# entities can be initialised with populated slots
params.value_1=entity.stato(value=10,name='Value 1',type='numeric',
description='An example entity.stato object',
stato.id='STATO:0000047'),

# entity.stato objects can have a stato.id
params.value_2=entity.stato(value=10,name='Value 1',type='numeric',
description='An example entity.stato object',
stato.id='STATO:0000047'),
```

***

A stato.id can be set for `entity.stato` objects enabling STATO integration for 
parameters and outputs as well as model objects. It is a good idea to set 
`name`, `description` and `stato.id` slots here, when the object is defined.


***

Parameters dont have to be entities, but this is not recommended as there is no
mechanism for providing long names and descriptions for these parameters.

```r
params.value_2 = 20,
```

***

Outputs can be included in the prototype, and we recommend `entity` or 
`entity.stato` objects for these too. They are created in the same way as 
params.


***

## Defining new methods for your model object

Model objects have a `model.train` and a `model.predict` function predefined by 
STRUCT, but by default it prints a warning that the method hasnt been 
implemented yet. You can override the default using the `setMethod` function. 
There are a number of inputs for `setMethod` as described in the following 
steps.

The `signature` option should include your new class as the first element, as 
this will direct R to use the correct `model.train` or `model.predict` function 
for your new model object.

```r
setMethod(f='model.train',                   # dont change this line
signature=c('model_template','dataset'), # replace model_template with... 
# ...your new model name
```

***

The description function is where you can include your own R code to train your 
model. Make sure you `return(M)` otherwise you model will not behave in the way 
expected by other StRUCT objects. 

```r
definition = function(M,D) {         # dont change this line
# do something here #
return(M)                        # make sure you return the model object
}
)

```

In the definition M is the model object, so that you can access parameter values
and D is the input dataset object, containing the data to train the model with.

***

Similarly, a `model.predict` method is provided so that you can apply your 
(trained) model to test data.

```r
setMethod(f='model.predict',                 # dont change this line
signature=c('model_template','dataset'), # replace model_template with... 
# ...your new model name
definition = function(M,D) {             # dont change this line
## do something here ##
# M is the model object
return(M)                            # make sure you return the model 
}
)

```

***

# Complete object

The final model object will look something like this working example:

```{r}
model_template=setClass('model_template', # replace model_template with ...
    # ...your new model name
    contains = c('model','stato'),       # stato is optional
    slots=c(                      # define your parameters and outputs here
        'params.value_0'='entity',
        'params.value_1'='entity.stato',
        'params.value_2'='numeric',
        'outputs.result_1'='entity',
        'outputs.result_2'='numeric'
    ),
    prototype = list( # specify default values for your parameters etc
        
        ## These are the default slots available for every struct object
        name='A test model',
        description='An example model object. Training adds value_1 counts to
    a dataset, while prediction adds value_2 counts.',
        type='test',
        
        ## This slot is only required for model.stato objects
        stato.id='OBI:0000011',
        
        ## parameters all start with params.
        # entities can be initialised with populated slots
        params.value_0=entity(name='Value 0',value=0,type='numeric'),
        
        # entity.stato objects can have a stato.id
        params.value_1=entity.stato(value=10,name='Value 1',type='numeric',
            description='An example entity.stato object',
            stato.id='STATO:0000047'),
        
        # params dont have to be entity objects but we dont recommend this.
        params.value_2=20,
        
        # entities can be initialised with populated slots
        outputs.result_1=entity(name='Result 1',type='dataset',
            description='An example entity object',value=dataset()),
        
        # outputs dont have to be entity objects but we dont recommend this.
        outputs.result_2=2
    )
)
```

You should include a method to train your model:
```{r}
# create a model.train method for your object
setMethod(f='model.train', # dont change this line
    signature=c('model_template','dataset'),  # replace model_template with...
    # ...your new model name
    definition = function(M,D) {              # dont change this line
        # do something here #
        return(M)                             # make sure you return the model
    }
)
```

You should also include a method for prediction using a trained model:
```{r}
# create a model.predict method for your object
setMethod(f='model.predict',                  # dont change this line
    signature=c('model_template','dataset'),  # replace model_template with...
    # ...your new model name
    definition = function(M,D) {              # dont change this line
        ## do something here ##
        return(M)                             # make sure you return the model 
    }
)
```

***

Similar approaches can be used to make other struct objects, such as methods and charts.





